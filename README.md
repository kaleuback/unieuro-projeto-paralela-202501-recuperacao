# PARALIZAÇÃO DE SOMA COM THREADS EM PYTHON

# LEIA!!!!!!! O CÓDIGO EM PYTHON PURO É LIMITADO PELO GIL (EXPLICAÇÃO ABAIXO DOS RESULTADOS), COM ISSO ESTUDEI SOBRE E VI QUE A SOLUÇÃO É OU USAR BIBLIOTECAS QUE LIBERAM O GIL OU USAR MULTIPROCESSAMENTO, ENTENDO QUE NÃO É O OBJETIVO DA ATIVIDADE USAR O MULTIPROCESSAMENTO E SIM THREADS PORÉM É DAS SOLUÇÕES TAMBÉM, FIZ 3 CÓDIGOS E 3 TABELAS DE RESULTADOS: 1 EM PYTHON PURO, 1 USANDO BIBLIOTECAS PARA "DESBLOQUEAR" O GIL E POR ÚLTIMO EM MULTIPROCESSAMENTO.

# CONFIGURAÇÃO DO COMPUTADOR USADO PARA TESTES
- PROCESSADOR: INTEL COM 2 NÚCLEOS FÍSICOS / 4 THREADS LÓGICAS  
- FREQUÊNCIA BASE: 2,20 GHZ  
- VIRTUALIZAÇÃO: HABILITADA  
- CACHE L1: 128 KB  
- CACHE L2: 512 KB  
- CACHE L3: 3,0 MB  
- SOCKETS: 1  

# LIMITAÇÃO DO GIL NO PYTHON PURO COM THREADS

| THREADS | TEMPO (S) | SPEEDUP | EFICIÊNCIA |
|---------|-----------|---------|------------|
| 1       | 8.6629    | 1.0000  | 1.0000     |
| 2       | 13.3591   | 0.6485  | 0.3242     |
| 4       | 11.7121   | 0.7397  | 0.1849     |
| 8       | 12.5895   | 0.6881  | 0.0860     |

Soma: 5049448532

# ANÁLISE:
APESAR DA SOMA PARALELA RETORNAR O RESULTADO CORRETO, O DESEMPENHO PIORA EM RELAÇÃO À VERSÃO SERIAL. ISSO OCORRE POIS O GIL LIMITA A EXECUÇÃO SIMULTÂNEA DE CÓDIGO PYTHON PURO A UMA ÚNICA THREAD POR VEZ. PORTANTO, MULTIPLAS THREADS NÃO GERAM PARALELISMO REAL, CAUSANDO SOBRECARGA E QUEDA DE DESEMPENHO.

# SOLUÇÃO 1: USANDO NUMPY PARA LIBERAR O GIL INTERNAMENTE

| THREADS | TEMPO (S) | SPEEDUP | EFICIÊNCIA |
|---------|-----------|---------|------------|
| 1       | 0.0650    | 1.0000  | 1.0000     |
| 2       | 0.0440    | 1.4762  | 0.7381     |
| 4       | 0.0478    | 1.3594  | 0.3398     |
| 8       | 0.0507    | 1.2823  | 0.1603     |

Soma: 5050109388

# ANÁLISE:  
NESTE CASO, A FUNÇÃO DE SOMA USA `NUMPY.SUM`, IMPLEMENTADA EM C, QUE LIBERA O GIL DURANTE A EXECUÇÃO. ISSO PERMITE QUE MÚLTIPLAS THREADS FAÇAM CÁLCULOS EM PARALELO, GERANDO GANHOS DE DESEMPENHO, EMBORA LIMITADOS PELO OVERHEAD E CONTENÇÃO DE RECURSOS.

# SOLUÇÃO 2: USANDO MULTIPROCESSING PARA PARALELISMO REAL

| PROCESSOS | TEMPO (S) | SPEEDUP | EFICIÊNCIA |
|-----------|-----------|---------|------------|
| 1         | 0.0650    | 1.0000  | 1.0000     |
| 2         | 0.0360    | 1.8056  | 0.9028     |
| 4         | 0.0220    | 2.9545  | 0.7386     |
| 8         | 0.0175    | 3.7143  | 0.4643     |

Soma: 5049778442

# ANÁLISE:  
NESTE CASO, A SOMA É PARALELIZADA ENTRE MÚLTIPLOS PROCESSOS INDEPENDENTES, CADA UM COM SEU PRÓPRIO INTERPRETADOR PYTHON E SEM COMPARTILHAR GIL. ISSO PERMITE PARALELISMO REAL EM TAREFAS CPU-BOUND, REDUZINDO SIGNIFICATIVAMENTE O TEMPO DE EXECUÇÃO E AUMENTANDO SPEEDUP E EFICIÊNCIA.

# CONCLUSÃO GERAL

O _GLOBAL INTERPRETER LOCK_ (GIL) DO PYTHON LIMITA A EXECUÇÃO PARALELA DE THREADS EM CÓDIGO CPU-BOUND, TORNANDO INEFICIENTE A PARALELIZAÇÃO COM THREADS PURAS.

PARA SUPERAR ESSA LIMITAÇÃO, DUAS ESTRATÉGIAS EFICAZES SÃO:

1. USO DE BIBLIOTECAS QUE LIBERAM O GIL INTERNAMENTE (EXEMPLO: NUMPY), PERMITINDO GANHO PARCIAL COM THREADS.  
2. USO DO MÓDULO `MULTIPROCESSING`, QUE CRIA MÚLTIPLOS PROCESSOS INDEPENDENTES, PERMITINDO PARALELISMO REAL E MAIOR GANHO DE DESEMPENHO.

ASSIM, AO PROJETAR SOLUÇÕES PARALELAS EM PYTHON PARA TAREFAS INTENSIVAS EM CPU, É FUNDAMENTAL ESCOLHER A ABORDAGEM ADEQUADA PARA MAXIMIZAR A PERFORMANCE.

# ESTRUTURA DO PROJETO

- `soma_puro_threads.py`: IMPLEMENTAÇÃO EM PYTHON PURO COM THREADS  
- `soma_numpy_threads.py`: USO DE NUMPY COM THREADS  
- `soma_multiprocessing.py`: USO DE MULTIPROCESSING PARA PARALELISMO REAL  


# REFERÊNCIAS

- DOCUMENTAÇÃO OFICIAL DO PYTHON SOBRE GIL: https://wiki.python.org/moin/GlobalInterpreterLock  
- NUMPY E LIBERAÇÃO DO GIL: https://numpy.org/devdocs/user/c-info.how-to-extend.html#releasing-the-gil  
- MULTIPROCESSING NO PYTHON: https://docs.python.org/3/library/multiprocessing.html  

# PROJETO DESENVOLVIDO PARA DISCIPLINA DE PROGRAMAÇÃO PARALELA - UNIEURO 2025/01

